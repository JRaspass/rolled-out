#!/usr/bin/env perl

use v5.38;

use File::Find;
use JSON::XS;
use Path::Tiny;

# World images from https://docs.rolledoutgame.com/worlds.html resize with
# convert xxx.jpg -resize "200^>" -gravity center -crop 200x200+0+0 xxx.jpg
my @worlds = map { code => code($_), name => $_, slug => slug($_) }, (
    'Tranquility', 'Desert Ruins', 'Candy Factory', 'Foggy Mountains',
    'Virtual Reality', 'Ice Cave', 'Volcano', 'Haunted Grounds',
    'Heavenly Chamber', 'Desolation', 'Vortex',
);

my %bg2world = (
    BonusMap        => 0,
    SupernovaMap    => 0,
    GrassyHillsMap  => $worlds[0],  # Tranquility
    DesertTempleMap => $worlds[1],  # Desert Ruins
    CandyShopMap    => $worlds[2],  # Candy Factory
    GothicMap       => $worlds[3],  # Foggy Mountains
    VRMap           => $worlds[4],  # Virtual Reality
    IceCaveMap      => $worlds[5],  # Ice Cave
    VolcanoMap      => $worlds[6],  # Volcano
    SpookyMap       => $worlds[7],  # Haunted Grounds
    ExtraMap        => $worlds[8],  # Heavenly Chamber
    DesolationMap   => $worlds[9],  # Desolation
    MasterMap       => $worlds[10], # Vortex
);

my %skip = (
    # Tranquility / Scaling Test - Scoring not enabled.
    'e848dd7d-7efd-4d65-8300-6834830afdce' => 1,

    # Desert Ruins / Snakeway - Scoring not enabled.
    'a7baa939-a0d3-4e46-8bca-66bcf1774861' => 1,

    # Ice Cave / Keyholes - Not actually in the game?
    '0021375d-5893-48cc-8d9b-eeab5ce8e1be' => 1,
);

# Find all the stage config files in the Steam directory.
my @json;
find sub { push @json, path $File::Find::name if $_ eq 'config.json' },
    "$ENV{HOME}/.steam/steam/steamapps/common/rolledout/RolledOut/Content/Stages";

for my $json (@json) {
    my $conf = decode_json( $json->slurp );

    my $bg = $conf->{background_map};
    next unless my $world = $bg2world{$bg} // die "Can't find $bg\n";

    next if $skip{ $conf->{metadata}{uuid} };

    push $world->{stages}->@*, my $stage = {
        id    => $conf->{metadata}{uuid},
        name  => $conf->{metadata}{name}{fallback},
        slug  => slug( $conf->{metadata}{name}{fallback} ),
        timer => $conf->{timer_seconds},
    };

    say $stage->{name};

    my $png = $json->sibling('preview512.png');
    my $jpg = path("assets/img/$world->{slug}")->mkdir->child("$stage->{slug}.jpg");
    if ( $png->exists ) {
        system 'convert', $png, -'resize' => '200x200', $jpg and die $@;
    }
}

$_->{stages}->@* = sort { $a->{name} cmp $b->{name} } $_->{stages}->@*
    for @worlds;

path('model/worlds.json')->spew(
    JSON::XS->new->canonical->pretty->encode(\@worlds));

# Tranquility  → Tr
# Desert Ruins → DR
sub code($name) {
    return 'Vol' if $name eq 'Volcano';
    return 'Vor' if $name eq 'Vortex';

    return join( '', $name =~ /([A-Z]).+([A-Z])/ ) || $name =~ /(..)/;
}

# Tranquility  → tranquility
# Desert Ruins → desert-ruins
sub slug($name) {
    $name = lc $name;
    $name =~ s/&/and/g;
    $name =~ s/'//g;
    $name =~ s/\W+/-/g;
    $name =~ s/-$//;
    return $name;
}
